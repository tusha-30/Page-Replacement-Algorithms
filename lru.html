<!DOCTYPE html>
<html>
<head>
	<title>LRU PAGE REPLACEMENT</title>
	<style style="background-color: red;">
	#ADV{
		color: RED;
		background-color: yellow;
		margin-top: 50PX;
		padding: 71PX;
		font-size: 20PX;
		font-family: COURIER;
		}
	</style>
</head>
<body >


<img src="https://scaler.com/topics/images/lru-page-replacement-algorithm.webp"  style="max-width: 40%;float: right;">
<DIV ID="ADV" ><H1>Least Recently Used (LRU) Page Replacement Algorithm</H1>
	
	<p>The least recently used page replacement algorithm keeps the track of usage of pages over a period of time. This algorithm works on the basis of the principle of locality of a reference which states that a program has a tendency to access the same set of memory locations repetitively over a short period of time. So pages that have been used heavily in the past are most likely to be used heavily in the future also.
</p>
<p>In this algorithm, when a page fault occurs, then the page that has not been used for the longest duration of time is replaced by the newly requested page.</p>
<p>
Example: Let’s see the performance of the LRU on the same reference string of 3, 1, 2, 1, 6, 5, 1, 3 with 3-page frames:
	</p>
	<p>Initially, since all the slots are empty, pages 3, 1, 2 cause a page fault and take the empty slots.
Page faults = 3
</p>
<p>
When page 1 comes, it is in the memory and no page fault occurs.
Page faults = 3
</p>
<p>
When page 6 comes, it is not in the memory, so a page fault occurs and the least recently used page 3 is removed.
Page faults = 4
</p>
<p>
When page 5 comes, it again causes a page fault and page 1 is removed as it is now the least recently used page.
Page faults = 5
</p>
<p>
When page 1 comes again, it is not in the memory and hence page 2 is removed according to the LRU.
Page faults = 6
</p>
<p>
When page 3 comes, the page fault occurs again and this time page 6 is removed as the least recently used one.
Total page faults = 7</p>
<p>Now in the above example, the LRU causes the same page faults as the FIFO, but this may not always be the case as it will depend upon the series, the number of frames available in memory, etc. In fact, on most occasions, LRU is better than FIFO.</p>
<hr>
<H1>ADVANTAGES</H1>
	<UL>
		<LI>Doesn’t suffer from Belady’s anomaly
</LI>
		<LI>Often more efficient than other algorithms </LI>
		
</UL>
<H1>DISADVANTAGES</H1>
	<UL>
		<LI>More complex</LI>
		<LI>High hardware assistance is required</LI>
		<li>It requires additional data structures to be implemented</li>
		
</UL>
</DIV>

</body>

